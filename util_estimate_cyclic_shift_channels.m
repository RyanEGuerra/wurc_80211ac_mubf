function [H_ret, peak_inds, H_extra, rx_cfo_est_lts, rx_snr_est, rx_noise_variance] = util_estimate_cyclic_shift_channels( OPTS, RX_VEC_T )
%function [H_ret, peak_inds, H_extra, rx_cfo_est_lts, rx_snr_est] = util_estimate_cyclic_shift_channels( OPTS, RX_VEC_T )
% 
% This function both cleans and folds your laundry.
%
% But really, it takes a time-domain receive vector along with a number of
% parameters defining the format of the transmission, most of them
% generated by util_gen_cyclic_shift_preamble.m, and outputs the channel
% estimates of the PLCP preambles detected within.
%
% Autocorrelation detection metric adapted from: "Robust Frequency and
% Timing Synchronization for OFDM," T. Schmidl, D. Cox, IEEE Transactions
% on Communications, Vol 45, No. 12, December 1997
%
% MINN packet detection metric adapted from: "On Timing Offset Estimation
% for OFDM Systems," H. Minn, M. Zeng, V.K. Bhargava; IEEE Communications
% Letters, Vol 4, No. 7, July 2000
%
% REN packet SNR estimation algorithm from: "SNR Estimation Algorithm Based
% on the Preamble for ODFM Systems in Frequency Selective Channels," G.
% Ren, H. Zhang, Y. Chang, IEEE Transactions on Communications, Vol 57, No
% 8, August 2009
%
% AUTO_CORR packet detection metric adapted from Mango Communication's PLCP
% cross-correlation detector in example WARPLab scripts.
% http://warpproject.org
%
% [L-STF][L-LTF][TVHT-LTF_1]...[TVHT-LTF_N]
%
% The output channel estimates, OPTS.H_f, are contained in cells, one set
% of N_SC x N_STREAM estimates per cell.
%
% INPUTS:  RX_VEC_T                     Input Row-major Sample Vector
%          OPTS.NUM_STREAMS             N
%          OPTS.SEL_PREAMBLE_TYPE       {TVHT20, TVHT40}
%          OPTS.NUM_LTF                 How many LTS in a TVHT-LTF?
%          OPTS.APPLY_CFO_CORRECTION
%          OPTS.FFT_OFFSET              Number of extra CP samples to consume
%          OPTS.P                       Mapping Matrix
%          OPTS.NUM_FRAMES              Total number of TVHT-LTF frames
%          OPTS.VHT_LTF_F               The VHT-LTF in frequency-domain
%          OPTS.METRIC_TYPE             'MINN', 'CROSS_CORR', 'CS_CROSS_CORR'
%          OPTS.ADDL_AGC_TIME           Additional time to delay detection
%                                       based on the length of additional
%                                       samples you've added to the
%                                       beginning of the transmit vector to
%                                       allow AGC on WARP to settle.
%          OPTS.EXTRA_LTF_STS           DEFAULT: 0
%                                       [0,8] extra LTFs to expect after
%                                       the VHTLTF, which we use for physi-
%                                       cal channel sounding. 
%          OPTS.ENABLE_DEBUG            DEFAULT: 0
%          OPTS.VERBOSE                 DEFAULT: 0
%          OPTS.ENABLE_XCORR_BOUNDING   DEFAULT: 1
%   
% OUTPUTS: H_ret                        Cell array with channel estimates
%          peak_inds                    Optional peak indices, they point
%                                       to the estimated LAST sample of the
%                                       L-LTF used for timing extraction.
%          H_extra                      When OPTS.EXTRA_LTF_STS > 0, the
%                                       extra set of H-estimates are output
%          rx_cfo_est_lts               The calculated CFO estimate
%          rx_snr_est                   The N_STS x N_SC SNR estimate of
%                                       the received signal.
%
%
% NOTE: I don't remove the non-zero subcarriers, so the output H_f has
%       values of infinity where the transmitted subcarriers are zero.
%       YOU must check this condition.
%
%
% Example Usage
% =============
% > PREAM.NUM_STREAMS = 8;
% > PREAM.SEL_PREAMBLE_TYPE = 'TVHT40';
% > PREAM = util_gen_cyclic_shift_preamble(PREAM);
% > TX_VEC = transpose([PREAM.STF_ARRAY, PREAM.GF_LTF_ARRAY, PREAM.LTF_ARRAY]);
% > TX_VEC = sum(TX_VEC, 2); % poor man's antenna combining
% > PREAM.APPLY_CFO_CORRECTION = 1;
% > PREAM.FFT_OFFSET = 3;
% > PREAM.NUM_FRAMES = 1;
% > H_est = util_estimate_cyclic_shift_channels(PREAM, TX_VEC);
%
%
% (c) ryan@guerra.rocks 2015
% http://www.apache.org/licenses/LICENSE-2.0

    DEBUG_CROSS_CORR = 0;               % Debug flags. Keep these off.
%     OPTS.ENABLE_DEBUG = 1;
    DEBUG_ANALOG_SIGNAL = 0;            % <-- This debug flag is old; don't set.
    DEBUG_SNR_ESTIMATE = 0;
    DEBUG_SMOOTHING = 0;    
            
    % Default debug settings, etc... Can be overridden by setting in the
    % OPTS struct passed to this function
    if ~isfield(OPTS, 'ENABLE_XCORR_BOUNDING')
        OPTS.ENABLE_XCORR_BOUNDING = 1;
    end
    if ~isfield(OPTS, 'VERBOSE')
        OPTS.VERBOSE = 0;
    end
    if ~isfield(OPTS, 'ENABLE_DEBUG')
        OPTS.ENABLE_DEBUG = 0;
    end
    if ~isfield(OPTS, 'EXTRA_LTF_STS')
        OPTS.EXTRA_LTF_STS = 0;
    end 
    if ~isfield(OPTS, 'ENABLE_SNR_ESTIMATE')
        OPTS.ENABLE_SNR_ESTIMATE = 1;
    end 
    if ~isfield(OPTS, 'ENABLE_SMOOTHING')
        % NOTE: this is disabled by default because a beamformed packet
        % should NOT be smoothed. Arbitrary random phase differences are
        % supposedly expected between subcarriers when beamforming.
        OPTS.ENABLE_SMOOTHING = 0;
    end 
    if ~isfield(OPTS, 'ENABLE_DEBUG_POINTS')
        OPTS.ENABLE_DEBUG_POINTS = 0;
    end 
    % Channel sounding flag indicates that this packet contains an extra
    % VHTLTF pair, so that the channel is sounded twice in order to
    % provide data for a multi-stream SNR output.
    if ~isfield(OPTS, 'SOUND_CHANNEL')
        OPTS.SOUND_CHANNEL = 0;
    end
    
    if ~isfield(OPTS, 'DEBUG_FIG_NUM')
        DEBUG_FIG_NUM = randi(5000);
    else
        DEBUG_FIG_NUM = OPTS.DEBUG_FIG_NUM;
    end
    
    % The normalized threshold above which to look for cross_corr peaks.
    % The default values work for many cases, but were not working on the
    % channel emulator in MIMO Bypass mode for some reason (might be low
    % correlation due to high initial attenuation, perhaps).
    if ~isfield(OPTS, 'CROSSCORR_DETECTION_THRESH')
        OPTS.CROSSCORR_DETECTION_THRESH = 0.8;
    end
    if ~isfield(OPTS, 'CSCROSSCORR_DETECTION_THRESH')
        OPTS.CSCROSSCORR_DETECTION_THRESH = 0.76;
    end
    
    
    % default values for punting.
    H_ret = [];
    peak_inds = [];
    H_extra = [];
    rx_cfo_est_lts = [];
    rx_snr_est = [];
    rx_noise_variance = [];
    
    % 'CROSS_CORR', 'MINN', 'CS_CROSS_CORR'
    METRIC_TYPE = OPTS.METRIC_TYPE;      

    % what is the minumum valid magnitude we need to declare a metric
    % valid?
    MIN_MAGNITUDE = 0.1;
    % set some detection parameters based on the method used
    if strcmp(OPTS.SEL_PREAMBLE_TYPE, 'TVHT20')
        L = 64;
        % Minn Fudges
        M1_fudge = -30-3;%L*3/4+3;
        SEARCH_BOUNDS = [25, 500] + OPTS.ADDL_AGC_TIME;
        disp(SEARCH_BOUNDS)
        % Cross-Corr Fudges
        % 03/07/2015 REG - subtracting 80 is a good value for this when two
        % Short training sequences are sent
        XCORR_BOUNDS = [1, round(L*8/2)-80] + OPTS.ADDL_AGC_TIME;
    elseif strcmp(OPTS.SEL_PREAMBLE_TYPE, 'TVHT40')
        L = 128;
        % Minn Fudges
        M1_fudge = -12;%L*3/4+12;
        SEARCH_BOUNDS = [50, 1200] + OPTS.ADDL_AGC_TIME;
        % Cross-Corr Fudges
        XCORR_BOUNDS = [1, round(L*7/2)] + OPTS.ADDL_AGC_TIME;
    else
        error(['Unknown preamble type: ' OPTS.SEL_PREAMBLE_TYPE]);
    end
    % Input time vector
    X = RX_VEC_T;
    if size(X, 2) ~= 1
        error('util_estimate_cyclic_shift_channels() can only handle N_samp x 1 time vectors!')
    end
    
    %% Calculate Schmitl-Cox Metric with L=FFT_LEN    
    % ========================= Auto-Correlation w/ MINN metric
    if strcmp(METRIC_TYPE, 'MINN') || OPTS.ENABLE_DEBUG
        X_orig = X;
        X(1:SEARCH_BOUNDS(1)) = 0;
        X(SEARCH_BOUNDS(2):end) = 0;
                
        % Calculate the inner part of the summation
        P_com = zeros(length(X)-L, 1); %preallocate
        R_com = zeros(length(X)-L, 1); %preallocate
        for d = 1:length(X)-L 
            P_com(d) = conj(X(d)).*X(d+L);
            R_com(d) = abs(X(d+L)).^2;
        end

        % Calculate the sum of above values for Schmitl-Cox
        P = zeros(length(X)-2*L, 1);
        R = zeros(length(X)-2*L, 1);
        for d = 1:length(X)-2*L
            P(d) = sum(P_com(d:d+L));
            R(d) = sum(R_com(d:d+L));
        end
        M = abs(P).^2./(R.^2);

        % Calculate extended window for Minn
        Mm = 2*L;
        Rf = zeros(length(X)-3*L, 1);
        for d = 1:length(X)-3*L
            Rf(d) = sum(R_com(d:d+Mm));
        end
        Rf = Rf/2;
        Mf = abs(P(1:length(Rf))).^2./(Rf.^2);
        lag = L;
        % Make the metric peak at around 
        M1 = zeros(length(Mf)-lag + 2*L, 1);
        for d = lag+1:1:length(Mf)-lag
            M1(d-lag + 2*L) = sum(Mf(d-lag:d)); 
        end
        % pad the beginning to make the index point work out
        M1 = [zeros(lag,1); M1];
        % window the M1 metric so that we don't get start/stop transients
        bound_M1 = M1;%M1(SEARCH_BOUNDS(1):SEARCH_BOUNDS(2));
        bound_M1(SEARCH_BOUNDS(2):end) = 0;
        M1_max_ind = find(M1 == max(bound_M1));
        X = X_orig;
    end
    % ========================= Cross-Correlation
    if strcmp(METRIC_TYPE, 'CROSS_CORR') || OPTS.ENABLE_DEBUG
        % Calculate detection result for Cross-Correlation
        lts_corr = abs(conv(conj(fliplr(OPTS.VHTLTF_T)), (X)));
        % bound lts_corr
        lts_corr_unbounded = lts_corr;
        if OPTS.ENABLE_XCORR_BOUNDING
            lts_corr(1:XCORR_BOUNDS(1)) = 0;
            lts_corr(XCORR_BOUNDS(2):end) = 0;
        end
        Mcc = lts_corr;
%         lts_corr(end-SEARCH_BOUNDS(2)+1:end) = zeros(SEARCH_BOUNDS(2), 1);
        lts_peaks = find(lts_corr > OPTS.CROSSCORR_DETECTION_THRESH*max(lts_corr));
        [LTS1, LTS2] = meshgrid(lts_peaks, lts_peaks);
        [lts_2nd_peak_ind, y] = find(LTS2-LTS1 == L);
        dup_inds = diff(lts_peaks(lts_2nd_peak_ind)) < L/4;
        % remove the lower indices from consideration
        lts_2nd_peak_ind(dup_inds) = [];
        if OPTS.ENABLE_DEBUG && DEBUG_CROSS_CORR
            figure(153)
            plot(lts_corr);
            hold on;
            thr = OPTS.CROSSCORR_DETECTION_THRESH*max(lts_corr);
            plot([0 length(lts_corr)], [thr thr], '--r');
            plot(lts_peaks, lts_corr(lts_peaks), 'm.', 'MarkerSize', 30);
            plot(lts_peaks(lts_2nd_peak_ind), ...
                 lts_corr(lts_peaks(lts_2nd_peak_ind)), ...
                 'g.', 'MarkerSize', 18);
            hold off;
            title(['Debug LTS Correlation Output: ' num2str(lts_peaks(lts_2nd_peak_ind).')]);
        end
        % Punt if no valid correlation peak was found
        if(isempty(lts_2nd_peak_ind)) && strcmp(METRIC_TYPE, 'CROSS_CORR') && OPTS.VERBOSE
            warning([mfilename ': No LTS Correlation Peaks Found']);
        end
    end
    % ========================= Cyclic Shifted Cross-Correlation
    if strcmp(METRIC_TYPE, 'CS_CROSS_CORR') || OPTS.ENABLE_DEBUG
        ref_sig = OPTS.L_LTF_ARRAY_T(:,end-OPTS.NUM_SC+1:end);
        % this assumes perfect antenna combining with unitary channels
        % a big assumption, but what else are we going to correlate against
        % in the cyclicly-shifted case?
        ref_sig = sum(ref_sig, 1);
        cslts_corr = abs(conv(conj(fliplr(ref_sig)), (X)));
        cslts_corr(1:OPTS.ADDL_AGC_TIME) = 0;
        Mcs = cslts_corr;
%         cslts_corr(end-SEARCH_BOUNDS(2)+1:end) = zeros(SEARCH_BOUNDS(2), 1);
        cslts_peaks = find(cslts_corr > OPTS.CSCROSSCORR_DETECTION_THRESH*max(cslts_corr));
        [LTS1, LTS2] = meshgrid(cslts_peaks, cslts_peaks);
        [cslts_2nd_peak_ind, y] = find(LTS2-LTS1 == L);
        dup_inds = diff(cslts_peaks(cslts_2nd_peak_ind)) < L/4;
        % remove the lower indices from consideration
        cslts_2nd_peak_ind(dup_inds) = [];
        if OPTS.ENABLE_DEBUG && DEBUG_CROSS_CORR
            figure(153)
            plot(cslts_corr);
            hold on;
            thr = OPTS.CROSSCORR_DETECTION_THRESH*max(cslts_corr);
            plot([0 length(cslts_corr)], [thr thr], '--r');
            plot(cslts_peaks, cslts_corr(cslts_peaks), 'm.', 'MarkerSize', 30);
            plot(cslts_peaks(cslts_2nd_peak_ind), ...
                 cslts_corr(cslts_peaks(cslts_2nd_peak_ind)), ...
                 'g.', 'MarkerSize', 18);
            hold off;
            title(['Debug CS-LTS Correlation Output: ' num2str(cslts_peaks(cslts_2nd_peak_ind).')]);
        end
        % Punt if no valid correlation peak was found
        if(isempty(cslts_2nd_peak_ind)) && strcmp(METRIC_TYPE, 'CS_CROSS_CORR') && OPTS.VERBOSE
            warning([mfilename 'ERROR: No LTS Correlation Peaks Found!\n']);
        end
    end
    
    % Select the timing point for channel estimation based on the timing
    % metric type. At this time, I highly recommend using the MINN method,
    % since I've shown it to be more robust in high AWGN environments with
    % the cyclic-shifted preambles, but it has real issues with the
    % AGC-corrupted railed values and the post-packet zero padding since it
    % relies on auto-correlation. REG
    switch(METRIC_TYPE)
        %==================================================================
        case 'SCHMITL_COX'
            error('Do not use SCHMITL_COX option. Use MINN instead.')
        %==================================================================
        case 'CROSS_CORR'
            % Points to last sample of the second LTS.
            % URI - it seems that there is only one peak, why is that?
            % anyway, make a special case for it.
%             if length(lts_peaks) == 1
%                 peak_inds = lts_peaks;
%                 num_peaks = 1;
%             else
                peak_inds = lts_peaks(lts_2nd_peak_ind); 
                num_peaks = length(peak_inds);
%             end
        %==================================================================
        case 'CS_CROSS_CORR'
            % Points to last sample of the second LTS.
            peak_inds = cslts_peaks(cslts_2nd_peak_ind); 
            num_peaks = length(peak_inds);
        %==================================================================
        case 'MINN'
            % Points to last sample of the second LTS.
            peak_inds = M1_max_ind+M1_fudge; 
            num_peaks = length(peak_inds);
        otherwise
            error(['Choose a valid metric: ' METRIC_TYPE]);
    end
        
    % sanity check - if you get this error, set the debug flag up top and
    % try processing again. You'll get an analysis plot
    if num_peaks ~= OPTS.NUM_FRAMES && OPTS.VERBOSE
        warning([mfilename ': Found ' num2str(num_peaks) ' frames when expecting ' num2str(OPTS.NUM_FRAMES)]);
    end
    
    % Some debug plotting. Use the flags at head of file else plotting
    % values won't be computed
    if OPTS.ENABLE_DEBUG
        figno = DEBUG_FIG_NUM;
        if OPTS.VERBOSE
            disp([mfilename ': Fig ' num2str(figno)]);
        end
        figure(figno);
        clf;
        nump = 5;
        ax(1) = subplot(nump,1,1);
            plot(abs(X))
            hold on;
%             plot(M1_max_ind + M1_fudge, abs(X(M1_max_ind + M1_fudge)), '.m', 'markersize', 25);
            plot(M1_max_ind, abs(X(M1_max_ind)), '.m', 'markersize', 25);
            %
            plot(lts_peaks(lts_2nd_peak_ind), abs(X(lts_peaks(lts_2nd_peak_ind))), '.g', 'markersize', 20);
            plot(cslts_peaks(cslts_2nd_peak_ind), Mcs(cslts_peaks(cslts_2nd_peak_ind)), '.r', 'markersize', 15);
%             plot(ind, abs(X(ind)), '.m', 'markersize', 20)
            vline(SEARCH_BOUNDS, '--');
            hold off;
            title('Input Time Vector: X')
        ax(2) = subplot(nump,1,2);
            plot(lts_corr_unbounded, 'k')
            hold on;
            plot(Mcc, 'b')
            plot(lts_peaks(lts_2nd_peak_ind), Mcc(lts_peaks(lts_2nd_peak_ind)), '.g', 'markersize', 20);
            vline(XCORR_BOUNDS, '--');
            hline(OPTS.CROSSCORR_DETECTION_THRESH*max(lts_corr), ':');
            hold off;
            title('Cross Correlation Metric: "Mango"');
        ax(3) = subplot(nump,1,3);
            plot(Mcs)
            hold on;
            plot(cslts_peaks(cslts_2nd_peak_ind), Mcs(cslts_peaks(cslts_2nd_peak_ind)), '.r', 'markersize', 20);
%             ylim([0,1])
            vline([OPTS.ADDL_AGC_TIME], '--');
            hline(OPTS.CSCROSSCORR_DETECTION_THRESH*max(cslts_corr), ':');
            hold off;
            title('CS - Cross Correlation Metric');
        ax(4) = subplot(nump,1,4);
            maxval = max(max([abs(P), R]));
            plot(abs(P)./maxval, 'r');
            hold on;
            plot(R./maxval, 'g');
            plot(M, 'k');
            vline(SEARCH_BOUNDS, '--');
            hold off;
            legend('P normalized', 'R normalized', 'M');
            title('Schmitl-Cox Metric (Autocorrelation)')
        ax(5) = subplot(nump,1,5);
            M1_inds = 1:1:length(M1);
            plot(M1_inds, M1);
            hold on;
            plot(M1_max_ind, M1(M1_max_ind), '.m', 'markersize', 20);
            ylim([0,300]);
            vline(SEARCH_BOUNDS, '--');
            hold off
            title('Minn Metric (Autocorrelation)')
%         ax(5) = subplot(nump,1,5);
%             
%         ax(6) = subplot(nump,1,6);
            
        linkaxes(ax, 'x');
    end    
    
    if OPTS.ENABLE_DEBUG_POINTS
        % Plot timing point extraction results
        try
            disp(['Cross-Corr:    [' num2str(lts_peaks(lts_2nd_peak_ind).') ']']);
            disp(['CS-Cross-Corr: [' num2str(cslts_peaks(cslts_2nd_peak_ind).') ']']);
            disp(['Minn:          [' num2str(M1_max_ind+M1_fudge) ']']);
            disp(['Sh-Cox:        [' num2str(0) ']']);
        catch fred
			warning([mfilename ': debug text output threw an error!']);
%             keyboard
        end
    end
    
            
    %% Correct for CFO in the received time-domain samples
    
    if OPTS.APPLY_CFO_CORRECTION
		% CFO Correction algorithm taken from Mango Communications reference
		% code: http://warpproject.org
        for pp = 1:1:num_peaks
            % estimate and apply CFO correction to this single PLCP
            % timing point - CPCP - OFFSET = points to first L-LTF symbol
            ind = peak_inds(pp) - L*2 - OPTS.FFT_OFFSET;

            % Segment LTS samples
            lts_1 = X(ind:ind+L-1);
            lts_2 = X(ind+L:ind+2*L-1);
       
            rx_cfo_est_lts = mean(unwrap(angle(lts_1 .* conj(lts_2))));
            rx_cfo_est_lts = rx_cfo_est_lts/(2*pi*L);
            
            rx_cfo_corr_t = exp(1i*2*pi*(rx_cfo_est_lts)*[0:length(X)-1]);
            X = X.* rx_cfo_corr_t.';
            
        end
    else
        rx_cfo_est_lts = inf;
        % don't do nothin
    end
    
    %% Some extra setup if this vector includes an extra VHTLTF sequence
    % There doesn't seem to be an elegant way to precompute this because
    % the number of streams != number of Tx antennas, so the extra number
    % of physical streams is arbitrary. Rather than try to figure it out,
    % we'll just have the beamforming processing code pass the number of
    % physical streams and we'll re-compute the required P and N_LTF to
    % process the channel estimate. A little extra processing time, but
    % really not much.
    if OPTS.EXTRA_LTF_STS
        if OPTS.VERBOSE
            disp([mfilename ': Decoding with extra channel sounding VHTLTF...']);
        end
        if OPTS.SOUND_CHANNEL && OPTS.VERBOSE
            disp([mfilename ': Calculating sounded SNR from extra VHTLTF sequence...']);
        end
        
        % When the number of spatial stream equals the index, this is the number of
        % required VHT-LTF repetitions. (802.11ac Table 22-13)
        NUM_VHT_LTFS_REQUIRED_ARR = [1;2;4;4;6;6;8;8];
        
        % How many extra LTF sequences should we expect?
        % Note that when num_streams = 3, 4 VHTLTF symbols are transmitted
        % Thus we use NUM_TX_ANTENNAS here instead of EXTRA_LTF_STS
        try
            EXTRA_LTF = NUM_VHT_LTFS_REQUIRED_ARR(OPTS.EXTRA_LTF_STS);
        catch myerr
            % I had some issues here getting 3 streams with 4 VHTLTFs to
            % work properly. So I'm leaving this here... REG 11/11/2015
            warning('%s: dimension assignment mismatch. Dropping into keyboard to debug...', mfilename);
            keyboard;
        end
        
        % The 801.11af TVHT-LTF mapping matrix comes from 20.3.9.4.6 of 802.11-2012
        % as well as section 22.3.8.3.5 in 802.11ac, and 23.3.4.7 in 802.11af
        % This generates the orthogonal mapping matrix for the TVHT-LTF
        % sequences. Use P_4x4 for N<=4, P_6x6 for N<=6, and P_8x8 for N<=8, where
        % N = number of spatial streams.
        % Grab the correct P matrix, and Legacy/TVHT Cyclic Shift
        if OPTS.EXTRA_LTF_STS <= 4
            P_4x4 = [ 1 -1  1  1;...
                      1  1 -1  1;...
                      1  1  1 -1;...
                     -1  1  1  1];
            EXTRA_P = P_4x4(1:OPTS.EXTRA_LTF_STS, 1:EXTRA_LTF);
        elseif OPTS.EXTRA_LTF_STS <= 6
            i = sqrt(-1);
            w = exp(-i*2*pi/6);
            P_6x6 = [1 -1    1    1    1    -1;...
                     1 -w^1  w^2  w^3  w^4  -w^5;...
                     1 -w^2  w^4  w^6  w^8  -w^10;...
                     1 -w^3  w^6  w^9  w^12 -w^15;...
                     1 -w^4  w^8  w^12 w^16 -w^20;...
                     1 -w^5  w^10 w^15 w^20 -w^25];
            EXTRA_P = P_6x6(1:OPTS.EXTRA_LTF_STS, 1:EXTRA_LTF);
        elseif OPTS.EXTRA_LTF_STS <= 8
            P_4x4 = [ 1 -1  1  1;...
                      1  1 -1  1;...
                      1  1  1 -1;...
                     -1  1  1  1];
            P_8x8 = [P_4x4,     P_4x4;...
                     P_4x4, -1.*P_4x4];
            EXTRA_P = P_8x8(1:OPTS.EXTRA_LTF_STS, 1:EXTRA_LTF);
        else
            error(['way too many spatial streams: ' num2str(PREAM.EXTRA_LTF_STS)]);
        end
    end

    %% Isolate VHT-LTS Samples & Estimate Channel
    % Preallocate H result vector: subc, path, frame
    OPTS.H_f = {};
    II = [];
    H_ret = {};     % allocate so that failing to find peaks doesn't crash
    H_extra = {};
    H_extra2 = {};
    for pp = 1:1:num_peaks
        % the metrics chosen above should generate a timing point that is
        % pointing to the last sample of the L-LTF.
        % timing point + 1 - OFFSET = points to start of first TVHT-LTF
        ind = peak_inds(pp) + 1 - OPTS.FFT_OFFSET;

        % Extract the LTF samples
        Y_t = ones(L, OPTS.NUM_LTF)*inf; %preallocate
        for ss = 1:1:OPTS.NUM_LTF
            Y_t(:,ss) = X(ind+L/4:ind+5*L/4-1);
            
            if DEBUG_ANALOG_SIGNAL
                % saved for debug plotting
                II = [II, ind+L/4:ind+5*L/4-1];
            end
            
            ind = ind + 5*L/4;
        end
         
        % Perform FFT on each PLCP frame
        % Note that FFT operates along the column
        Y_f = fft(Y_t, L);
        % Estimate channel using P Mapping Matrix
        % There should be a more efficient way to do this. It's basically a
        % 2D matrix multiply carried out L times. Will consult someone
        % else.
        Pt = transpose(OPTS.P);
        % The standard defines the vector with the zero-freq component in
        % the center. MATLAB FFT output has the zero-freq component at
        % position 1. FFTSHIFT puts DC at center, IFFTSHIFT puts DC at left
        VHTLTF = transpose(ifftshift(OPTS.VHTLTF_F));
        H_f = ones(L, OPTS.NUM_STREAMS)*inf; % preallocate
        for subc = 1:1:L
            % [Y1, Y2, Y3, Y4]*P.'/(N_ltf*VHTLTF_k)
            tmp = Y_f(subc,:)*Pt/(OPTS.NUM_LTF*VHTLTF(subc));
%             tmp = Pt*(Y_f(subc,:).')/(OPTS.NUM_LTF*VHTLTF(subc));
            tmp(isinf(tmp)) = 0;
            H_f(subc,:) = tmp;
        end
        H_ret{pp} = fftshift(H_f, 1);
        Y_ret{pp} = Y_f;
        
        % =================================================================
        % Repeat the channel estimate with the extra STF fields
        if OPTS.EXTRA_LTF_STS
            % picking up indices from where we left off, grab the next set of
            % channel estimation LTFs.
            Y_t2 = ones(L, EXTRA_LTF)*inf; %preallocate
            for ss = 1:1:EXTRA_LTF
                Y_t2(:, ss) = X(ind+L/4:ind+5*L/4-1);

                if DEBUG_ANALOG_SIGNAL
                    % saved for debug plotting
                    II = [II, ind+L/4:ind+5*L/4-1];
                end

                ind = ind + 5*L/4;
            end
            Y_f2 = fft(Y_t2, L);
            Pt2 = transpose(EXTRA_P);
            H_f2 = ones(L, OPTS.EXTRA_LTF_STS)*inf; % preallocate
            for subc = 1:1:L
                % [Y1, Y2, Y3, Y4]*P.'/(N_ltf*VHTLTF_k)
                tmp = Y_f2(subc,:)*Pt2/(EXTRA_LTF*VHTLTF(subc));
                tmp(isinf(tmp)) = 0;

                H_f2(subc, :) = tmp;
            end
            H_extra{pp} = fftshift(H_f2, 1);
            Y_extra{pp} = Y_f2;
            
            % If sounding the channel, then not only is there an extra set
            % of LTF fields, but there are TWO extra sets to get SNR
            % information.
            if OPTS.SOUND_CHANNEL
                Y_t3 = ones(L, EXTRA_LTF)*inf; %preallocate
                for ss = 1:1:EXTRA_LTF
                    Y_t3(:, ss) = X(ind+L/4:ind+5*L/4-1);

                    if DEBUG_ANALOG_SIGNAL
                        % saved for debug plotting
                        II = [II, ind+L/4:ind+5*L/4-1];
                    end

                    ind = ind + 5*L/4;
                end
                Y_f3 = fft(Y_t3, L);
                H_f3 = ones(L, OPTS.EXTRA_LTF_STS)*inf; % preallocate
                for subc = 1:1:L
                    % [Y1, Y2, Y3, Y4]*P.'/(N_ltf*VHTLTF_k)
                    tmp = Y_f3(subc,:)*Pt2/(EXTRA_LTF*VHTLTF(subc));
                    tmp(isinf(tmp)) = 0;

                    H_f3(subc, :) = tmp;
                end
                H_extra2{pp} = fftshift(H_f3, 1);
                Y_extra2{pp} = Y_f3;
            end % end OPTS.SOUND_CHANNEL
        end % end OPTS.EXTRA_LTF_STS
    end
        
    %% Channel Estimate Smoothing
    if OPTS.ENABLE_SMOOTHING
        SMOOTHING_TYPE = 'sgolay';     % moving, rlowess, sgolay
        SMOOTHING_WINDOW = 5;          % how many samples... (keep small for CS channels)
                
        % Smooth the channel estimate
        if ~isempty(H_ret)
            for sts = 1:1:size(H_ret{1}, 2)
                rx_H_est_sm = H_ret{1}(OPTS.NONZERO,sts); 
                rx_H_est_sm_re = smooth(real(rx_H_est_sm), SMOOTHING_WINDOW, SMOOTHING_TYPE);
                rx_H_est_sm_im = smooth(imag(rx_H_est_sm), SMOOTHING_WINDOW, SMOOTHING_TYPE);
                rx_H_est_sm = rx_H_est_sm_re + 1i*rx_H_est_sm_im;
                if DEBUG_SMOOTHING
                    plotthis([H_ret{1}(OPTS.NONZERO,sts), rx_H_est_sm]);
                    plotthis([real(H_ret{1}(OPTS.NONZERO,sts)), ...
                              imag(H_ret{1}(OPTS.NONZERO,sts)), ...
                              rx_H_est_sm_re, ...
                              rx_H_est_sm_im]);
                end
%                 H_ret{1}(OPTS.NONZERO,sts) = rx_H_est_sm;
            end
        end
        
        % Smooth the H_extra estimate
        if ~isempty(H_extra)
            for sts = 1:1:size(H_extra{1}, 2)
                rx_H_est_sm = H_extra{1}(OPTS.NONZERO,sts); 
                rx_H_est_sm_re = smooth(real(rx_H_est_sm), SMOOTHING_WINDOW, SMOOTHING_TYPE);
                rx_H_est_sm_im = smooth(imag(rx_H_est_sm), SMOOTHING_WINDOW, SMOOTHING_TYPE);
                rx_H_est_sm = rx_H_est_sm_re + 1i*rx_H_est_sm_im;
                H_extra{1}(OPTS.NONZERO,sts) = rx_H_est_sm;
            end
        end
        % Smooth the H_extra2 estimate
        if ~isempty(H_extra2)
            for sts = 1:1:size(H_extra2{1}, 2)
                rx_H_est_sm = H_extra2{1}(OPTS.NONZERO,sts); 
                rx_H_est_sm_re = smooth(real(rx_H_est_sm), SMOOTHING_WINDOW, SMOOTHING_TYPE);
                rx_H_est_sm_im = smooth(imag(rx_H_est_sm), SMOOTHING_WINDOW, SMOOTHING_TYPE);
                rx_H_est_sm = rx_H_est_sm_re + 1i*rx_H_est_sm_im;
                H_extra2{1}(OPTS.NONZERO,sts) = rx_H_est_sm;
            end
        end
    end
    
    %% Preamble-based Rx SNR Estimation on the Received L-LTS
    
    if OPTS.ENABLE_SNR_ESTIMATE
        % I could honestly not figure out why the estimated SNR and the
        % simulation input SNR were almost exactly 9 dB (8x) apart all the
        % time. Still don't know. But since it's consistent....
        SNR_FUDGE = 9.5;
        
        % Sometimes the estimated SNR is so low, we end up with a negative
        % value. Lower bound the measured SNR since at this level, we need
        % a different method to estimate it accurately.
        SNR_MIN_VALUE = -20;
        
        % First, try to perform the multi-stream SNR estimate us the two
        % copies of the VHTLTF.
        if isempty(peak_inds)
            % Don't crash and burn here if the timing point is missed
            if OPTS.VERBOSE
                warning([mfilename ': Setting SNR to infinity!']);
            end
            rx_snr_est = inf;
        elseif (OPTS.EXTRA_LTF_STS == OPTS.NUM_STREAMS)
            % This method relies on two copies of the VHTLTF sounding
            % sequence to obtain H1 and H2, two estimates of the channel.
            % The difference between them is the expectation of the noise,
            % and the power of the channel is considered the signal +
            % noise. Thus SNR per subcarrier k per stream is: 
            % SNR_k = ||H_k||^2/||H1_k-H2_k||^2 - 1;
            H1 = H_ret{1};
            H2 = H_extra{1};
            % Note: there may be an N_LTF term
            try
                W_ms = (H1-H2);% * OPTS.P .* repmat(ifftshift(VHTLTF), 1, OPTS.NUM_STREAMS);
            catch myerr
                warning('kybard');
                keyboard
            end
            % Note: H1 and H2 have had padding and DC subcarriers zeroed
            % out. Thus, the sum is only averaging over NON-Zero subcs.
            % The 1/2 term comes from the E{||Z1-Z2||^2} = 2*Z_pwr for AWGN.
            rx_noise_variance = sum(abs(W_ms).^2, 1)/(OPTS.NUM_STREAMS*length(OPTS.NONZERO));
            Z_pwr = rx_noise_variance/2;
            P_sc = ( abs(H1).^2 + abs(H2).^2 )/2;
            % Before, I took the mean noise measured across "all four paths"
            % but I'm not sure that's correct. I'm also not sure that this
            % is correct, either. It's difficult to say in the multistream
            % case...
            USE_MEAN_NOISE = 0;
            SNR_sc = zeros(length(OPTS.NONZERO), size(P_sc, 2)); %preallocate
            for path = 1:1:size(P_sc, 2)
                if USE_MEAN_NOISE
                    SNR_sc(:,path) = 10*log10(P_sc(OPTS.NONZERO.', path)/mean(Z_pwr) - 1);
                else
                    SNR_sc(:,path) = 10*log10(P_sc(OPTS.NONZERO.', path)/(Z_pwr(path)) - 1);
                end
            end
%             SNR_sc(~isreal(SNR_sc)) = SNR_MIN_VALUE;
            SNR_sc_re = real(SNR_sc);
            SNR_sc_im = imag(SNR_sc);
            SNR_sc_re(SNR_sc_im>0.00001) = SNR_MIN_VALUE;
            SNR_sc_re(SNR_sc_re<SNR_MIN_VALUE) = SNR_MIN_VALUE;
            SNR_sc = SNR_sc_re;
            mean_snr_ms = mean(SNR_sc, 1);
            
            rx_snr_est = SNR_sc - SNR_FUDGE;
            if DEBUG_SNR_ESTIMATE
                figure(299)
                    p_db = (SNR_sc);
                    p_db(~isreal(p_db)) = 0;
                    p_db = real(p_db);
                    plot([OPTS.NONZERO] - L/2 - 1, p_db);
                    grid on;
                    title(['Multi-Stream SNR Estimate Per Subcarrier, Mean: ' num2str(mean_snr_ms - SNR_FUDGE)]);
                    ylabel('SNR (dB)');
                    xlabel('Subcarrier');
            end
        elseif (OPTS.SOUND_CHANNEL)
            % This section should only get called for beamformed packets
            % with an extra VHTLTF sounding pair.
            H1 = H_extra{1};
            H2 = H_extra2{1};
%             Pt2 = transpose(EXTRA_P);

            try
%                 NUM_VHTLTF_SYMBOLS = NUM_VHT_LTFS_REQUIRED_ARR(OPTS.EXTRA_LTF_STS);
                W_ms = (H1-H2);% * Pt2 .* repmat(ifftshift(VHTLTF), 1, NUM_VHTLTF_SYMBOLS);
            catch myerr
                warning([mfilename ': encountered an unexpected dimension problem. Dropping into keyboard...']);
                keyboard; % I had some issues with a 3xN channel here due to NUM_LTF not being correct. REG 11/2015
            end
            rx_noise_variance = sum(abs(W_ms).^2, 1)/(OPTS.EXTRA_LTF_STS*length(OPTS.NONZERO));
            Z_pwr = rx_noise_variance/2;
            P_sc = ( abs(H1).^2 + abs(H2).^2 )/2;
            USE_MEAN_NOISE = 0;
            SNR_sc = zeros(length(OPTS.NONZERO), size(P_sc, 2)); %preallocate
            for path = 1:1:size(P_sc, 2)
                if USE_MEAN_NOISE
                    SNR_sc(:,path) = 10*log10(P_sc(OPTS.NONZERO.', path)/mean(Z_pwr) - 1);
                else
                    SNR_sc(:,path) = 10*log10(P_sc(OPTS.NONZERO.', path)/(Z_pwr(path)) - 1);
                end
            end
            SNR_sc_re = real(SNR_sc);
            SNR_sc_im = imag(SNR_sc);
            SNR_sc_re(SNR_sc_im>0.00001) = SNR_MIN_VALUE;
            SNR_sc_re(SNR_sc_re<SNR_MIN_VALUE) = SNR_MIN_VALUE;
            SNR_sc = SNR_sc_re;
            rx_snr_est2 = SNR_sc - SNR_FUDGE;
        else
            rx_snr_est2 = inf;
        end
           
        % Try the Ren Estimator for single-stream with only the L-LTF when
        % the secondary set of VHTLTFs is not enabled.
        if isempty(peak_inds)
            % Don't crash and burn here if the timing point is missed
            rx_snr_est = inf;
        elseif (OPTS.NUM_STREAMS == 1) && (OPTS.EXTRA_LTF_STS ~= OPTS.NUM_STREAMS)
            % Ren assumes channel is identical between training symbols
            % and can only work for one spatial stream estimate.
            % Y_m,k = m-th rx symbol, k-th subcarrier,
            % c_m,k = m-th training symbol, k-th subcarrier
            % W = 1/(2N) sum()
            % estimate and apply CFO correction to this single PLCP
            % timing point - LTFLTF - OFFSET = points to start of first L-LTF symbol
            ind = peak_inds(1) - L*2 - OPTS.FFT_OFFSET;
            % Segment LTS samples
            lts_1_t = X(ind:ind+L-1);
            lts_2_t = X(ind+L:ind+2*L-1);
            lts_1_f = fftshift(fft(lts_1_t, L));
            lts_2_f = fftshift(fft(lts_2_t, L));
            % I missed this step the first time I implemented it; it
            % doesn't matter, but it would if the preamble were complex. IT
            % should also handle removing the sign.
            % This step assumes that ||VHTLTF_k|| == 1;
            Yp1 = zeros(size(lts_1_f)); Yp2 = zeros(size(lts_2_f));
            Yp1 = lts_1_f;
            Yp2 = lts_2_f;
            try
                Yp1(OPTS.NONZERO) = lts_1_f(OPTS.NONZERO) .* conj(OPTS.VHTLTF_ARRAY_F(OPTS.NONZERO));
                Yp2(OPTS.NONZERO) = lts_2_f(OPTS.NONZERO) .* conj(OPTS.VHTLTF_ARRAY_F(OPTS.NONZERO));
            catch err
                warning([mfilename ': Dropping into keyboard!'])
                keyboard
            end
            % Ren estimate of noise power, taken from ALL subcarriers
            W_hat = sum( abs(Yp1-Yp2).^2 )/(2*L);
            % Save this for reporting to the processor.
            rx_noise_variance = W_hat;
            % Ren estimate of per-subcarrier power (two symbols)
            M_2_hat = sum( [abs(Yp1).^2, abs(Yp2).^2], 2 )/2;
            % Only calculate SNR for non-zero subcarriers.
            % Note that the Ren metric doesn't work for multiple streams.
            p_hat = 10*log10(M_2_hat(OPTS.NONZERO)/W_hat - 1);
            
            p_hat_re = real(p_hat);
            p_hat_imag = imag(p_hat);
            p_hat_re(p_hat_imag>0.00001) = SNR_MIN_VALUE;
            p_hat_re(p_hat_re<SNR_MIN_VALUE) = SNR_MIN_VALUE;
            p_hat = p_hat_re;
           
            mean_snr = mean(p_hat);
            % If the noise is white, and we expect not too much fading across
            % subcarriers, then we could report scalar mean_snr rather than the
            % per-subcarrier estimate, p_hat. At this time, we'll stay
            % conservative and return the whole vector.
            rx_snr_est = p_hat - SNR_FUDGE;
            if DEBUG_SNR_ESTIMATE
                figure(298)
                    p_db = (p_hat);
                    p_db(~isreal(p_db)) = 0;
                    p_db = real(p_db);
                    plot([OPTS.NONZERO] - L/2 - 1, p_db);
                    grid on;
                    title(['Ren L-LTF SNR Estimate Per Subcarrier, Mean: ' num2str(mean_snr - SNR_FUDGE)]);
                    ylabel('SNR (dB)');
                    xlabel('Subcarrier');
            end
        elseif (OPTS.EXTRA_LTF_STS == 0)
            if OPTS.VERBOSE
                warning([mfilename ': No SNR estimated. Send one stream, or set OPTS.EXTRA_LTF_STS = N_STS'])
            end
            rx_snr_est = inf;
        end % Ren SNR Estimate
        
        if OPTS.SOUND_CHANNEL
            if exist('rx_snr_est2')
                rx_snr_est = {rx_snr_est, rx_snr_est2};
            end
        end
        
    else
        % SNR Estimate is disabled
        rx_snr_est = inf;
    end % if 
    
%     if size(H_extra{1},2) == 4 % dEBUG STUFF
%         warning('%s: DEBUG dropping into keyboard...');
%         keyboard
%     end
    
%     if isinf(rx_snr_est)
%         warning('No rx_snr_est was set! Dropping into keyboard...')
%         keyboard;
%     end
    
    %% Debug Channel Estimation by Showing Which Time-Domain Samples I Grabbed.
    if DEBUG_ANALOG_SIGNAL
%         M_norm = M/max(M);
%         bound_M1_norm = bound_M1/max(bound_M1);
        % Plot to show that I extracted the correct time-domain values
        figure(551)
        clf;
        plot(abs(X), ':g');
        hold on;
        plot(II, abs(X(II)));
%         plot(M_norm.*max(abs(X)), '-r');
%         plot_inds = 1:1:length(bound_M1_norm.*max(abs(X)));
%         plot(plot_inds+SEARCH_BOUNDS(1), bound_M1_norm.*max(abs(X)), '-m');
        hold off;
        title('Time Domain LTS Extraction: Blue = LTSs');
        xlabel('Sample Time');
        ylabel('Magnitude');
    end
end

function [] = vline(x, format_str)
%function [] = vline(x, format_str)
%   draws a vertical line @ x. can accept an array
    V = axis();
    for ind = 1:1:length(x)
        ell = line([x(ind) x(ind)],[V(3) V(4)]);
        set(ell, 'LineStyle', format_str);
        set(ell, 'Color', 'r');
    end
end

function [] = hline(y, format_str)
%function [] = hline(y, format_str)
%   draws a horizontal line @ y. can accept an array
    V = axis();
    for ind = 1:1:length(y)
        ell = line([V(1) V(2)], [y(ind) y(ind)]);
        set(ell, 'LineStyle', format_str);
        set(ell, 'Color', 'r');
    end
end